#include "../Project_Headers/address_map_arm.h"
#include <stdio.h>
#include "../Project_Headers/address_registers.h"



/* key_pressed and pattern is written by an interrupt service routines; we have to
 * declare these as volatile to avoid the compiler caching their values in
 * registers */

volatile int operationComplete = 0; 	// interrupt enable signal 

/* **************************************************
******************************
 * This program demonstrates use of interrupts with C code. 
 
 * Initially the value of the switches is represented on the LEDs
 
 * Each time any of the Pushbuttons is pressed the value of variable key_pressed
 * is changed. When the value of this variabl is 0 the value of the switches
 * is represented on the LEDs. When its value is 1 the value of the switches is 
 * represented on the LEDs, but LED9 is ON independently of the value establiched
 * in the switches
********************************************************************************/

	
int main(void)
{

	volatile int *slv_reg0 = (int *)REG0_BASE_ADDRESS;
	volatile int *slv_reg1 = (int *)REG1_BASE_ADDRESS;
	volatile int *slv_reg2 = (int *)REG2_BASE_ADDRESS;
	volatile int *slv_reg3 = (int *)REG3_BASE_ADDRESS;
	
    	set_A9_IRQ_stack();      		// initialize the stack pointer for IRQ mode
    	config_GIC();            		// configure the general interrupt controller
	enable_A9_interrupts(); 		// enable interrupts
    
    	/*If the optional part of laboratory 4 is implemented, enable the interrupts
	generated by the multiplier by writing a value 1 in bit 3 of slv_reg3.*/

    	*slv_reg3 = *(slv_reg3) | (1 << 3);  	// set irq_enable	
    	printf("\nProgram starts...\n");
	
    while (1)
    {
		// verify there is not a pending multiplication by checking the interrupt enable signal 
		
		
		
		if (operationComplete==1){
			
			operationComplete=0;
			printf("Result: %i \n", *slv_reg2);

			*slv_reg3 = *(slv_reg3) & ~(1 << 0); 			// set start to 0
			*slv_reg2 = *slv_reg2 & ~(0xFFFFFFFF); 		// set result slv_reg2 to 0
			*slv_reg1 = *slv_reg1 & ~(0xFFFFFFFF); 		// set result slv_reg1 to 0
			*slv_reg0 = *slv_reg0 & ~(0xFFFFFFFF); 		// set result slv_reg0 to 0
			
		}

		/* Verify that there is not a pending multiplication by checking bit 1 of slv_reg3 (busy output of the 			multiplier) */
		if(((*slv_reg3 >> 1) & 1) == 0) { // check if busy = 0
    		
            		/* Write the multiplicand on slv_reg0 */ 
    			printf("\nEnter first operand: ");
    			scanf("%d", slv_reg0);
            
			/* Write the multiplier on slv_reg1 */
    			printf("Enter second operand: ");
    			scanf("%d", slv_reg1);
            
            		/* Start the multiplication by writing a value 1 on bit 0 of slv_reg3 
            		(start input of the multiplier) */
    			*slv_reg3 = *(slv_reg3) | 1;  // set start to 1
    			
    			for (int i = 0; i < 100; i++) {
    			}


    	}
    }
}

